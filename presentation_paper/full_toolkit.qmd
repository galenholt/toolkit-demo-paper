---
title: "Simple toolkit template"
echo: true
---

## Getting started

There are many options for each of the steps here, this is a minimal, quick example designed to get you something that works quickly and can be modified. *In particular, we would expect the aggregation sequences and figures to need to be tailored for each analysis.*

See (in development) [documentation website](https://mdbauth.github.io/WERP_toolkit_demo/) for more detailed examples and discussion of capabilities.

Each step saves metadata about its parameters, which can be used for parameter-based runs to replicate, as well as variables to use in plots.

### Load libraries

```{r}
#| message: false
library(HydroBOT)
library(sf)
library(dplyr)
library(ggplot2)
```


## User arguments

As a user, we need to set

-   Paths to input

-   Paths to save output

-   Module arguments (minimal)

-   Aggregation sequence and functions

-   Figures (typically interactive)

## Paths

```{r}
#demo_webdir <- file.path('../WERP_toolkit_demo')
demo_webdir <- file.path('~', '../Deakin University/QAEL - WERP in house - WERP/Toolkit/Writing/Demonstration paper')

# Why is the execute-dir not working?
# Outer directory 
project_dir = file.path(demo_webdir, 'demo_scenarios')  # '..', 

# Hydrographs
hydro_dir = file.path(project_dir, 'hydrographs')  

# EWR outputs
ewr_results <- file.path(project_dir, 'module_output', 'EWR')  

# outputs of aggregator
agg_results_1 <- file.path(project_dir, 'aggregator_output', 'sdl_target') 
agg_results_2 <- file.path(project_dir, 'aggregator_output', 'gauge_target') 

# outputs of aggregator
agg_results_pooled_ewrs <- file.path(project_dir, 'aggregator_output', 'pooled_ewr') 

```

## Module controls

EWR currently, will add others as available. For this demo, we'll return only the summary and yearly outputs, though all EWR outputs are available.
The `returnType` argument keeps them in-memory rather than saving and reading back in. To demonstrate, I'm not doing that but it would make sense for small runs.

```{r}
outputType <- list('summary', 'yearly')
returnType <- list('none') # list('summary', 'yearly')
```

## Aggregation sequencing

-   Sequence of steps

-   Sequence of functions

There are *many* ways to specify, these are simple.

The planning units sometimes overlap into the Lower Darling, which we don't want, so don't give them the option.
```{r}
sdl_clip <- sdl_units |> 
  filter(SWSDLName %in% c("Lachlan", "Namoi", "Macquarieâ€“Castlereagh"))
```


```{r}
aggseq_1 <- list(all_time = 'all_time',
               ewr_code = c('ewr_code_timing', 'ewr_code'),
               planning_unit = planning_units,
               env_obj =  c('ewr_code', "env_obj"),
               sdl_units = sdl_clip,
               #Specific_goal = c('env_obj', "Specific_goal"),
               Target = c('env_obj', 'Target'),
               mdb = basin,
               target_5_year_2024 = c('Target', 'target_5_year_2024'))


funseq_1 <- list('ArithmeticMean', 
               'CompensatingFactor',
               'ArithmeticMean',
               'ArithmeticMean',
               'SpatialWeightedMean',
               #'ArithmeticMean',
               'ArithmeticMean',
               'SpatialWeightedMean',
               'ArithmeticMean')


aggseq_2 <- list(all_time = 'all_time',
               ewr_code = c('ewr_code_timing', 'ewr_code'),
               #planning_unit = planning_units,
               env_obj =  c('ewr_code', "env_obj"),
               #sdl_units = sdl_clip,
               #Specific_goal = c('env_obj', "Specific_goal"),
               Target = c('env_obj', 'Target'),
               #mdb = basin,
               target_5_year_2024 = c('Target', 'target_5_year_2024'))


funseq_2 <- list('ArithmeticMean', 
               'CompensatingFactor',
               #'ArithmeticMean',
               'ArithmeticMean',
               #'SpatialWeightedMean',
               #'ArithmeticMean',
               'ArithmeticMean',
               #'SpatialWeightedMean',
               'ArithmeticMean')


aggseq_2 <- list(all_time = 'all_time',
               ewr_code = c('ewr_code_timing', 'ewr_code'),
               #planning_unit = planning_units,
               env_obj =  c('ewr_code', "env_obj"),
               #sdl_units = sdl_clip,
               #Specific_goal = c('env_obj', "Specific_goal"),
               Target = c('env_obj', 'Target'),
               #mdb = basin,
               target_5_year_2024 = c('Target', 'target_5_year_2024'))


funseq_2 <- list('ArithmeticMean', 
               'CompensatingFactor',
               #'ArithmeticMean',
               'ArithmeticMean',
               #'SpatialWeightedMean',
               #'ArithmeticMean',
               'ArithmeticMean',
               #'SpatialWeightedMean',
               'ArithmeticMean')


```

# Run the toolkit

Typically automatically

-   Run hydrographs through modules

-   Aggregate and save responses

-   Comparisons/analyses

## Run modules

-   Currently just EWR

-   Where are hydrographs

-   Where to save output

*Using `rparallel = TRUE` here would run in parallel over all scenarios.*
```{r}
#| message: false
# ewr_out <- prep_run_save_ewrs(hydro_dir = hydro_dir, 
#                               output_parent_dir = project_dir, 
#                               output_subdir = agg_results,
#                               outputType = outputType,
#                               returnType = returnType)

```

## Aggregate

Here, unlike the EWR tool, we will just return these to the active R session instead of saving.

-   Sequence (levels of each theme, space, time axis)

-   Aggregation functions at each step

-   Produces a list, with each sheet a step in the aggregation

```{r}
agged_data_1 <- read_and_agg(datpath = ewr_results, 
           type = 'achievement',
           geopath = bom_basin_gauges,
           causalpath = causal_ewr,
           groupers = 'scenario',
           aggCols = 'ewr_achieved',
           group_until = list(planning_unit_name = is_notpoint, 
                                gauge = is_notpoint),
            pseudo_spatial = 'planning_unit',
           aggsequence = aggseq_1,
           funsequence = funseq_1,
           saveintermediate = TRUE,
           namehistory = FALSE,
           keepAllPolys = FALSE,
           returnList = TRUE,
           savepath = agg_results_1)

agged_data_2 <- read_and_agg(datpath = ewr_results, 
           type = 'achievement',
           geopath = bom_basin_gauges,
           causalpath = causal_ewr,
           groupers = 'scenario',
           aggCols = 'ewr_achieved',
           group_until = list(planning_unit_name = is_notpoint, 
                                gauge = is_notpoint),
            pseudo_spatial = 'planning_unit',
           aggsequence = aggseq_2,
           funsequence = funseq_2,
           saveintermediate = TRUE,
           namehistory = FALSE,
           keepAllPolys = FALSE,
           returnList = TRUE,
           savepath = agg_results_2)
```

The new scenario names ensure uniqueness, but can be ugly. This could be avoided with a named list to the `scenarios` argument in `prep_run_save_ewrs`, but a robust, general approach is a work in progress.

```{r}
# The new scenario names ensure uniqueness, but can be ugly
agged_data <- purrr::map(agged_data, 
                         \(x) x |> 
                           mutate(scenario = stringr::str_remove_all(scenario, "_[A-z]*[0-9]*")))
```

